\documentclass[a4paper]{report}
\usepackage{apacite}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algcompatible}
\graphicspath{{Images/}}


\begin{document}
	%------------------------Cover-------------------------------------------------------------
	\begin{titlepage} 
		\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
		
		\center 
		
		\textsc{\large Project block 1.3}\\[0.5cm] 
		
		\HRule\\[0.4cm]
		
		{\huge\bfseries Compute chromatic numbers}\\[0.4cm] 
		
		\HRule\\[1.5cm]
		
		\textsc{\large Group 10}\\[0.5cm]

		\begin{minipage}{0.6\textwidth}
			\begin{flushleft}
				Tu Anh Dinh\\Michal Jarski\\Louis Mottet
			\end{flushleft}
		\end{minipage}
		~
		\begin{minipage}{0.3\textwidth}
			\begin{flushleft}
				Vaishnavi Velaga\\Rudy Wessels\\Oskar Wielgos
			\end{flushleft}
		\end{minipage}
		
		\vspace{2cm}
		
		Submited: Wednesday January 23, 2019
		
		
	\end{titlepage}
	
	
	
	
	
	%-------------------Title page-----------------------------------------------------------
	\begin{titlepage} 
		\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} 
		
		\center
		
		\textsc{\LARGE Maastricht University}\\[1.5cm]
		
		\textsc{\Large Department of Data Science and Knowledge Engineering}\\[0.5cm] 
		
		\textsc{\large Project block 1.3}\\[0.5cm] 
		
		\HRule\\[0.4cm]
		
		{\huge\bfseries Compute chromatic numbers}\\[0.4cm] 
		
		\HRule\\[1.5cm]
		
		\textsc{\large Group 10}\\[0.5cm]
		
		\begin{minipage}{0.6\textwidth}
			\begin{flushleft}
				Tu Anh Dinh\\Michal Jarski\\Louis Mottet
			\end{flushleft}
		\end{minipage}
		~
		\begin{minipage}{0.3\textwidth}
			\begin{flushleft}
				Vaishnavi Velaga\\Rudy Wessels\\Oskar Wielgos
			\end{flushleft}
		\end{minipage}
	
		 \vspace{1cm}
		Submited: Wednesday January 23, 2019
		\vspace{3cm}
		\begin{flushleft}
			Project coordinator: Prof. Jan Paredis
		\end{flushleft}
		
	\end{titlepage}
	
	%-----------------------------------------------------------------------------
	\chapter*{Preface}
	\pagenumbering{gobble}

	\addcontentsline{toc}{chapter}{Preface}
	

	\chapter*{Summary}
	\addcontentsline{toc}{chapter}{Summary}
	
	\tableofcontents
	
	\chapter*{Abbreviations and symbols}
	\addcontentsline{toc}{chapter}{List of abbreviations and symbols}
	
	%-----------------------------------------------------------------------------
	\chapter{Introduction}
	\pagenumbering{arabic}

	
	\chapter{Methods}
	This chapter describes the methods used for finding the lower bound, upper bound and if possible, the chromatic number of a graph. 
	\section{Overview}
	Given the limitation on execution time (2 minutes for each graph), methods that give out results fast are executed first. Algorithm \ref{alg:overview} describes the general execution flow.\\
	\begin{algorithm}
		\caption{General work flow}
		\label{alg:overview}
		\begin{algorithmic}[1]
			\REQUIRE graph
			\STATE upperbound = greedyUpperbound(graph)
			\STATE subgraphs = decompose(graph)
			\FORALL{subgraphs} 
				\STATE subUpperbound =  greedyUpperbound(subgraph)
				
				\STATE//Check all special cases
				\IF{subgraph has no vertex} 
					\STATE chromaticNumber of subgraph = 0
					\STATE Go to the next subgraph
				\ENDIF
				\IF{subgraph has no edge} 
				\STATE chromaticNumber of subgraph = 1
				\STATE Go to the next subgraph
				\ENDIF
				\IF{subgraph is bipartite} 
				\STATE chromaticNumber of subgraph = 2
				\STATE Go to the next subgraph
				\ENDIF
				\IF{subgraph is odd cycle} 
				\STATE chromaticNumber of subgraph = 3
				\STATE Go to the next subgraph
				\ENDIF
				\IF{subgraph is complete graph} 
				\STATE chromaticNumber of subgraph = number of vertices
				\STATE Go to the next subgraph
				\ENDIF
				\IF{subgraph is wheel graph} 
					\IF{number of vertices is odd} 
					\STATE chromaticNumber of subgraph = 3
					\STATE Go to the next subgraph
					\ELSE
					\STATE chromaticNumber of subgraph = 4
					\STATE Go to the next subgraph
					\ENDIF
				\ENDIF
				\STATE subLowerbound = 3
				\IF{subUpperbound = subLowerbound} 
				\STATE chromaticNumber of subgraph = 3
				\STATE Go to the next subgraph
				\ENDIF
				
				\STATE//Run brute-force
				\IF{number of vertices $<=$ 20} 
				\STATE chromaticNumber of subgraph = BruteForce(subgraph)
				\ENDIF 
			\ENDFOR

			\algstore{myalg}
			\end{algorithmic}
		\end{algorithm}

		\begin{algorithm}                     
			\begin{algorithmic} [1]     
			\algrestore{myalg}

			\STATE newUpperbound = max(subUpperbounds)
			
			\IF{newUpperbound $<$ upperbound} 
			\STATE //Update upper bound
			\STATE upperbound = newUpperbound 
			\ENDIF
			
			\STATE lowerbound = max(subLowerbounds)
			
			\IF{has found all chromatic numbers of subgraphs} 
			\STATE chromatic number = max(chromatic numbers of subgraphs)
			\ELSE
			\STATE lowerbound = max(chromatic numbers of subgraphs)
			\ENDIF
			
			\STATE geneticAlgorithm(graph)
		\end{algorithmic}
	\end{algorithm}
	First, a greedy algorithm is run on the given graph to calculate the upper bound. Then, the given graph is decomposed to disconnected subgraphs. For each subgraph, the greedy algorithm is run again to find the upper bound. Then all special cases are checked to see if the chromatic number of the subgraph can be concluded immediately. The special cases are listed below: 
	\begin{itemize}
		\item No-vertex graph: chromatic number is 0
		\item No-edge graph: chromatic number is 1
		\item Bipartite graph: chromatic number is 2
		\item Odd cycle: chromatic number is 3
		\item Complete graph: chromatic number is the number of vertices
		\item Wheel graph: if the number of vertices is odd, then the chromatic number is 3, otherwise the chromatic number is 4
	\end{itemize}
	In line 35, if a subgraph is none of the special cases, the lower bound of the subgraph is 3, since the first three cases have covered all graphs where the chromatic number is below 3. If the upper bound is also 3, then the chromatic number of the subgraph is 3. \\
	If the chromatic number still cannot be concluded then a brute-force algorithm is used to find the chromatic number of the subgraph. However, only the subgraphs with number of vertices below 20 are proccessed with the brute-force algorithm, since the Brute-force algorithm normally takes longer than 2 minutes to execute on bigger graphs. \\
	After proccessing on the subgraphs, the upper bound, the lower bound and possibly the chromatic number of the original graph can be concluded. The biggest upper bound among the subgraphs is the upper bound of the original graph. This new upper bound is then compared to the old upper bound (computed in line 1) to output the better one. Similarily, the biggest lower bound among the subgraphs is the lower bound of the original graph. \\
	If the chromatic numbers of all subgraphs have been found, then the chromatic number of the original graph is the biggest chromatic number among the subgraphs. If it is not the case, then the biggest chromatic number found on the subgraphs is a lower bound for the original graph.\\
	Finally, genetic algorithm is used to bring the upper-bound closer to the chromatic number. Genetic algorithm is run last because there is no guarantee on its execution time.\\
	The algorithm for each method is described as follows.
	

		\section{Graph decomposition}
		One graph can contain multiple disconnected parts, which can be considered as independent subgraphs. Decomposing the graph will allow other methods to work on smaller graphs. Algorithm \ref{alg:decompose} describes the method for decomposing a graph into subgraphs, where each subgraph is a fully connected graph.\\
		\begin{algorithm}
			\caption{Decomposing a graph}
			\label{alg:decompose}
			\begin{algorithmic}[1]
				\REQUIRE graph
				Create listOfVertices in graph
				\WHILE{listOfVertices is not empty}
				\STATE Create a new subgraph
				\STATE Create a new uncheckedList
				\STATE subgraph.add(firstVertex in listOfVertices )
				\STATE uncheckedList.add(firstVertex in listOfVertices)
				\WHILE{uncheckedList is not empty} 
				\STATE checkingVertex = first vertex in the uncheckedList
				\FORALL{neighbors of checkingVertex} 
				\IF{neighbor is not in subgraph} 
				\STATE uncheckedList.add(neighbor)
				\STATE subgraph.add(neighbor)
				\ENDIF
				\ENDFOR
				\STATE Remove checkingVertex from uncheckedList
				\ENDWHILE
				\STATE Convert subgraph to standard form
				\STATE subgraphs.add(subgraph)
				\ENDWHILE
				\STATE \textbf{return} subgraphs
				
			\end{algorithmic}
		\end{algorithm}
		The algorithm is based on breadth-first search. A unchecked-list stores the vertices whose neighbors are not yet added to the same subgraph. Line 4 and 5 add the first vertex to a subgraph and the unchecked list. Then all neighbors of the vertex are added to the subgraph and the unchecked list, and remove the first vertex from the unchecked list. To avoid loops, only the vertices which are not in the subgraph are added. Do the same for all elements in the unchecked list, until the list is empty. Repeat the process until all vertices in the original graph are classified to subgraphs.\\
		After classifying the vertices to subgraphs, each subgraph is then converted to the standard form, where the index of vertices are successive.
		(Note that...)
		
		\section{Greedy algorithm}
		Greedy algorithm provides an efficient way of coloring the graph. However,  it does not guarantee that the coloring is optimal. Therefore, it can be used to calculate a upperbound. \\
		The algorithm works as follows:
		First, sort the vertices based on their constraints. The constraint of a vertex is  the number of other vertices which are connected to that vertex. The vertex with higher constraint will be colored first.\\
		Keep a list of used colors. When coloring a vertex, try to reuse the available colors. If non of the available colors is valid to color that vertex, then  a new color is generated, and add the new color to the available list. When the graph is fully colored, the number of colors in the available list is returned.\\
		
		\section{Lower-bound}
		
		\section{Special cases}
			\subsection{Bipartite}
			A bipartite graph is a graph that has chromatic number 2. Breadth-first search is used to test weather a graph is bipartite. Two colors, represented by 1 and -1, are used to color the graph. Keep a list to store the vertices whose neighbors are not yet considered. First, assign the color 1 to the first vertex and add it to the unchecked list. Then, consider all its neighbors, and remove it from the unchecked list. For each neighbors, if the neighbor has been colored, then we check if it is a valid coloring. If the coloring is invalid, the graph is not bipartite. If the neighbor has not been colored then assign the oposite color to it. Do the same for all elements in the unchecked list, until the list is empty. Repeat the process until all vertices in the original graph are colored. If the graph is successfully colored, then it is bipartite.
			\subsection{Odd cycle}
			An odd cycle is a cycle with an odd number of edges and vertices. The chromatic number of this kind of graph is 3. \\
			For the graph to be Cyclic, Two conditions must be satisfied:
			1.Number of Vertices should be equal to Number of Edges.
			2.Every Vertices must have two Edges.
			If above two conditions satisfied, then  the graph is Cyclic.
			
			\subsection{Complete graph}
			A complete graph is a graph where every vertex is connected to all other vertices. The chromatic number is the number of vertices. The method checks weather a graph has the above conditions to determine if it is a complete graph.
			Chromatic number = number of vertices
			\subsection{Wheel graph}
			A wheel graph is a graph formed by connecting a single vertex to all vertices of a cycle.
			To check whether a graph is wheel or not: First, find the center vertex of the graph and that vertex must be connected to all remaining vertices of the graph. Now, remove the  center from the graph. Check if all vertices except center vertex form a cycle.
			If the Graph is a wheel graph with odd number of vertices, then chromatic number is 3.
			Else if the graph is a wheel graph with even number of vertices, then chromatic number is 4.
			
			
		\section{Genetic algorithm}
			\subsection{Fitness function}
			Based on the number of invalid colorings of each graph
			\subsection{Selection method}
			\subsection{Crossover}
			\subsection{Mutation}
		
		\section{Brute force algorithm}
		
		
	\chapter{Experiments}
		
	\chapter{Results}
	
	\chapter{Discussion}
	
	\chapter{Conclusion}
	
	
	\bibliographystyle{apacite}
	\bibliography{references}
	
	\appendix
	\chapter*{Appendix}
	\addcontentsline{toc}{chapter}{Appendix}
\end{document}